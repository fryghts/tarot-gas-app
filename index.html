<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Цифровой Оракул: IT-Таро</title>
    <style>
        /* --- ОБЩИЕ СТИЛИ --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Orbitron:wght@400;700&display=swap');

        :root {
            --font-main: 'Inter', sans-serif;
            --font-title: 'Orbitron', sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-main);
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.5s;
            -webkit-user-select: none; -ms-user-select: none; user-select: none;
            touch-action: none;
        }

        .app-container {
            width: 100vw; height: 100vh; display: flex;
            justify-content: center; align-items: center;
            perspective: 2000px; position: relative; z-index: 1;
        }
        
        .app-container::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: #000;
            opacity: 0;
            z-index: 1;
            pointer-events: none;
            transition: opacity 2s ease-in-out;
        }
        .app-container.focus-active::before {
            opacity: 0.6;
        }

        #particles-js { position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: 0; }
        
        #confetti-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10000;
        }

        .screen {
            position: absolute; width: 100%; height: 100%; display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.8s;
            padding: 1rem; text-align: center;
            z-index: 2;
        }
        .screen.active { opacity: 1; pointer-events: auto; }
        .title { font-family: var(--font-title); font-size: clamp(2rem, 6vw, 4rem); font-weight: 700; margin-bottom: 1rem; }
        .subtitle { font-size: clamp(0.9rem, 2.5vw, 1.2rem); max-width: 600px; margin-bottom: 2rem; line-height: 1.6; }
        
        .shining-text {
            color: var(--secondary-color);
            text-shadow: 0 0 7px var(--highlight-color), 0 0 12px var(--highlight-color);
            animation: text-glow 3s ease-in-out infinite alternate;
        }
        @keyframes text-glow {
            from { text-shadow: 0 0 7px var(--highlight-color), 0 0 12px var(--highlight-color); }
            to { text-shadow: 0 0 12px var(--highlight-color), 0 0 24px var(--highlight-color), 0 0 4px #fff; }
        }

        .action-button {
            font-family: var(--font-title); padding: 1rem 2.5rem; border-radius: 50px; border: none;
            font-size: 1.1rem; cursor: pointer; transition: all 0.3s;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); touch-action: manipulation;
        }
        .action-button:hover { transform: translateY(-3px); box-shadow: 0 6px 25px rgba(0,0,0,0.4); }
        #logo-container { position: absolute; top: 1rem; left: 50%; transform: translateX(-50%); width: clamp(100px, 15vw, 150px); }
        #logo-container img { max-width: 100%; height: auto; filter: brightness(0) saturate(100%) invert(39%) sepia(82%) saturate(1347%) hue-rotate(191deg) brightness(96%) contrast(101%); }

        /* --- ТЕМЫ --- */
        .theme-gazprom-classic {
            --bg-color: #011d3a; --primary-color: #0078d7; --secondary-color: #ffffff;
            --text-color: #e0f7ff; --highlight-color: #00aaff; --card-back-bg: linear-gradient(145deg, #002f5c, #004b8f);
            --card-border: #00aaff;
        }
        .theme-gazprom-dark {
            --bg-color: #000814; --primary-color: #005f9e; --secondary-color: #ccdeeb;
            --text-color: #a9c7e0; --highlight-color: #3399ff; --card-back-bg: linear-gradient(145deg, #001a33, #002b52);
            --card-border: #0078d7;
        }
        .theme-gazprom-light {
            --bg-color: #e6f2ff; --primary-color: #005a9e; --secondary-color: #002d4f;
            --text-color: #004375; --highlight-color: #0078d7; --card-back-bg: linear-gradient(145deg, #cce5ff, #a3d1ff);
            --card-border: #005a9e;
        }
        
        .title { color: var(--secondary-color); text-shadow: 0 0 15px var(--primary-color); }
        .action-button { background-color: var(--primary-color); color: var(--bg-color) !important; }
        .action-button:hover { background-color: var(--highlight-color); }

        /* --- ЭКРАН ВЫБОРА (DRAG & DROP) --- */
        #choice-screen, #card-selection-area { position: absolute; inset: 0; overflow: hidden;}
        #initial-deck {
            position: absolute; top: 60%; left: 50%; width: 100px; height: 160px;
            transform: translate(-50%, -50%); cursor: pointer; transform-style: preserve-3d;
            transition: transform 0.3s, opacity 0.5s;
        }
        #initial-deck:hover { transform: translate(-50%, -50%) scale(1.05); }
        #initial-deck .shuffle-card {
            position: absolute; width: 100%; height: 100%; border-radius: 8px;
            background: var(--card-back-bg); border: 2px solid var(--card-border);
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        #spread-slots-sidebar {
            position: fixed; z-index: 20; background: rgba(0,0,0,0.3);
            border-radius: 10px; backdrop-filter: blur(10px); display: flex; gap: 10px;
        }
        .card-slot {
            width: 80px; height: 128px; border: 2px dashed var(--primary-color);
            border-radius: 8px; display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: var(--primary-color); transition: all 0.3s; font-size: 0.8rem;
        }
        .card-slot.drag-over { border-style: solid; transform: scale(1.05); }
        .card-slot .slot-label { font-family: var(--font-title); text-align: center; }

        .tarot-card {
            width: 80px; height: 128px; position: absolute; cursor: grab;
            transform-style: preserve-3d; border-radius: 6px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4); touch-action: none;
            transform: translateZ(0); /* Для улучшения рендеринга */
        }
        .tarot-card:active { cursor: grabbing; }
        .tarot-card.is-dragging { z-index: 1000; box-shadow: 0 8px 25px rgba(0,0,0,0.6); }
        
		.card-slot .tarot-card {
		  width: 100%;
		  height: 100%;
		  cursor: default;
		  position: relative;        
		  box-shadow: none;
		  display: block;
		  left: auto;
		  top: auto;
          /* Сохраняем 3D-контекст после попадания в слот */
          transform-style: preserve-3d;
		}

        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; border-radius: inherit;
            background-size: cover; background-position: center; border: 1px solid var(--card-border);
        }
        .card-back { background: var(--card-back-bg); }
        .card-front { transform: rotateY(180deg); }
		

        /* --- АДАПТИВНОСТЬ --- */
        @media (max-width: 768px) and (orientation: portrait) { #spread-slots-sidebar { bottom: 20px; left: 50%; transform: translateX(-50%); flex-direction: row; padding: 15px; } }
        @media (max-width: 768px) and (orientation: landscape) { #spread-slots-sidebar { right: 20px; top: 50%; transform: translateY(-50%); flex-direction: column; padding: 15px; } }
        @media (min-width: 769px) { #spread-slots-sidebar { right: 30px; top: 50%; transform: translateY(-50%); flex-direction: column; padding: 20px; } }
        @media (min-width: 1025px) { .card-slot { width: 100px; height: 160px; } #spread-slots-sidebar { right: 40px; } }
        
        /* --- МОДАЛЬНОЕ ОКНО И УВЕДОМЛЕНИЯ --- */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(10px); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.5s; padding: 10px; }
        .modal-overlay.active { opacity: 1; pointer-events: auto; }
        .modal-content { background: rgba(10, 20, 40, 0.95); border: 1px solid var(--primary-color); border-radius: 16px; padding: 1rem; width: 100%; max-width: 1000px; max-height: 90vh; overflow-y: auto; position: relative; box-shadow: 0 0 40px var(--primary-color); transform: scale(0.9); transition: transform 0.5s; }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .close-button { position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: var(--text-color); font-size: 2rem; cursor: pointer; opacity: 0.7; transition: opacity 0.3s, transform 0.3s; z-index: 10; }
        .close-button:hover { opacity: 1; transform: rotate(90deg); }
        .modal-spread-container { display: flex; flex-direction: column; gap: 1rem; }
        .modal-card-display { display: flex; gap: 1rem; background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 10px; border-left: 4px solid var(--primary-color); }
        .modal-card-display img { width: 80px; height: 128px; flex-shrink: 0; border-radius: 6px; border: 1px solid var(--card-border); object-fit: cover; }
        .card-details h4 { font-family: var(--font-title); color: var(--highlight-color); font-size: 1.2rem; margin-bottom: 0.5rem; }
        .card-details h5 { font-weight: bold; margin-top: 0.8rem; margin-bottom: 0.25rem; color: var(--secondary-color); font-size: 0.95rem; }
        .card-details p { font-size: 0.85rem; opacity: 0.9; line-height: 1.4; }
        .keywords-container { display: flex; flex-wrap: wrap; gap: 0.4rem; margin-top: 0.8rem; }
        .keyword { background: rgba(0,0,0,0.3); border: 1px solid var(--primary-color); padding: 0.2rem 0.6rem; border-radius: 15px; font-size: 0.7rem; }

        .placement-toast {
            position: fixed; bottom: 20%; left: 50%; background: rgba(10, 20, 40, 0.9);
            color: var(--text-color); padding: 1rem 2rem; border-radius: 8px;
            border-top: 3px solid var(--highlight-color); box-shadow: 0 5px 25px rgba(0,0,0,0.5);
            text-align: center; z-index: 9999; pointer-events: none;
            animation: toast-fade 2.5s ease-out forwards;
        }
        .placement-toast h4 { font-family: var(--font-title); color: var(--highlight-color); margin-bottom: 0.25rem; }
        @keyframes toast-fade {
            0% { opacity: 0; transform: translate(-50%, 20px); }
            15%, 85% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        #slot-explanation {
            position: absolute; top: 5%; left: 50%;
            transform: translateX(-50%); width: 90%; max-width: 500px;
            line-height: 1.8; transition: opacity 0.5s;
        }
        #slot-explanation strong { color: var(--highlight-color); font-weight: normal;}
        
        /* DEV PANEL */
        #dev-panel { position: fixed; bottom: 20px; left: 20px; z-index: 200; }
        #dev-panel-toggle { width: 50px; height: 50px; background: rgba(0,0,0,0.5); color: white; border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; border: 1px solid white; }
        #dev-panel-content { position: absolute; bottom: 60px; left: 0; background: rgba(0,0,0,0.8); border: 1px solid white; border-radius: 8px; padding: 1rem; width: 300px; display: none; grid-template-columns: 1fr; gap: 0.8rem; }
        #dev-panel-content.active { display: grid; }
        #dev-panel-content h4 { text-align: center; }
        .dev-group label { font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; }
        #dev-panel select, #dev-panel input, #dev-panel button { width: 100%; padding: 0.4rem; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
        #dev-panel button { cursor: pointer; background: var(--primary-color); margin-top: 0.5rem; }

        /* ЭФФЕКТЫ */
        .tarot-card.breathing-glow { animation: cardGlow 3.5s ease-in-out infinite; }
        
        /* ИСПРАВЛЕННЫЙ КОД СВЕЧЕНИЯ */
        @keyframes cardGlow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(0, 170, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 25px rgba(0, 170, 255, 0.9);
            }
        }
        
        .ripple-v1 { position: absolute; pointer-events: none; border-radius: 50%; background: radial-gradient(circle, rgba(0, 170, 255, 0.4) 0%, transparent 70%); transform: scale(0); animation: rippleEffect 0.6s ease-out; }
        @keyframes rippleEffect { to { transform: scale(4); opacity: 0; } }

        .card-slot.magnetic-pulse.attracting { transform: scale(1.08); border-style: solid; animation: magneticPulse 0.5s ease-in-out infinite alternate; }
        @keyframes magneticPulse { from { box-shadow: 0 0 15px var(--highlight-color); } to { box-shadow: 0 0 25px var(--highlight-color), 0 0 35px rgba(0, 170, 255, 0.5); } }

        #initial-deck.deck-breathing-mystic { animation: deckMystic 2.5s ease-in-out infinite; }
        @keyframes deckMystic { 0%, 100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1) drop-shadow(0 0 10px rgba(0, 170, 255, 0.3)); } 50% { transform: translate(-50%, -50%) scale(1.08); filter: brightness(1.1) drop-shadow(0 0 20px rgba(0, 170, 255, 0.8)); } }
    </style>
</head>
<body class="theme-gazprom-classic">

    <div id="particles-js"></div>
    <canvas id="confetti-canvas"></canvas>

    <div class="app-container">
        <div id="start-screen" class="screen active">
            <div id="logo-container"><img src="logo.svg" alt="Логотип" /></div>
            <h1 class="title">Цифровой Оракул</h1>
            <p class="subtitle">Какой баг ждет тебя в следующем спринте? Узнай свою IT-судьбу.</p>
            <button id="start-btn" class="action-button">Начать сеанс</button>
        </div>

        <div id="focus-screen" class="screen">
            <h1 class="title shining-text">Концентрация</h1>
            <p class="subtitle shining-text">Подумайте о проекте, карьерном пути или технологическом вызове, который вас волнует. Сконцентрируйтесь на нём.</p>
        </div>

        <div id="choice-screen" class="screen">
            <div id="card-selection-area"></div>
            <div id="spread-slots-sidebar">
                <div class="card-slot" data-slot-id="0"><span class="slot-label">Вызов</span></div>
                <div class="card-slot" data-slot-id="1"><span class="slot-label">Путь</span></div>
                <div class="card-slot" data-slot-id="2"><span class="slot-label">Исход</span></div>
            </div>
            <div id="slot-explanation" class="subtitle shining-text">
                Три карты определят твой путь.<br>
                Первая укажет на <strong>Вызов</strong>. Вторая откроет <strong>Путь</strong>.<br>
                Третья предскажет <strong>Исход</strong>.
            </div>
        </div>
    </div>

    <div id="result-modal" class="modal-overlay">
        <div class="modal-content">
             <button id="close-modal-btn" class="close-button">&times;</button>
            <div class="modal-spread-container"></div>
            <div class="gemini-section">
                <h3>Персональное толкование от AI</h3>
                <p>Задайте уточняющий вопрос, чтобы получить более глубокое предсказание.</p>
                <div class="gemini-input-group">
                    <input type="text" id="gemini-prompt" placeholder="Например: Какие скрытые риски есть в этом проекте?">
                    <button id="gemini-submit">Получить ответ</button>
                </div>
                <div id="gemini-response-container">
                    <div id="gemini-loader" class="loader" style="display: none;"></div>
                    <p id="gemini-response"></p>
                </div>
            </div>
        </div>
    </div>

    <div id="dev-panel">
        <div id="dev-panel-toggle">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.8293 10.1707C19.9392 10.7839 20 11.3895 20 12C20 12.6105 19.9392 13.2161 19.8293 13.8293L21.8293 15.3293C22.0678 15.513 22.1465 15.8329 22.0415 16.1159L20.0415 19.5819C19.9365 19.8649 19.6429 20.0351 19.3453 19.9707L16.9453 19.0707C16.3216 19.5393 15.6347 19.9234 14.8962 20.2101L14.5 22.7C14.4444 23.0041 14.1843 23.2204 13.8703 23.2204H10.1297C9.81568 23.2204 9.55558 23.0041 9.5 22.7L9.10383 20.2101C8.36531 19.9234 7.67842 19.5393 7.05471 19.0707L4.65471 19.9707C4.35714 20.0351 4.06346 19.8649 3.95848 19.5819L1.95848 16.1159C1.8535 15.8329 1.93221 15.513 2.17073 15.3293L4.17073 13.8293C4.06083 13.2161 4 12.6105 4 12C4 11.3895 4.06083 10.7839 4.17073 10.1707L2.17073 8.67073C1.93221 8.48705 1.8535 8.16712 1.95848 7.8841L3.95848 4.4181C4.06346 4.1351 4.35714 3.96486 4.65471 4.02928L7.05471 4.92928C7.67842 4.46071 8.36531 4.0766 9.10383 3.78988L9.5 1.3C9.55558 0.99593 9.81568 0.77965 10.1297 0.77965H13.8703C14.1843 0.77965 14.4444 0.99593 14.5 1.3L14.8962 3.78988C15.6347 4.0766 16.3216 4.46071 16.9453 4.92928L19.3453 4.02928C19.6429 3.96486 19.9365 4.1351 20.0415 4.4181L22.0415 7.8841C22.1465 8.16712 22.0678 8.48705 21.8293 8.67073L19.8293 10.1707ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16Z"/></svg>
        </div>
        <div id="dev-panel-content">
            <h4>Dev Panel</h4>
            <div class="dev-group">
                <label for="theme-select">Тема:</label>
                <select id="theme-select">
                    <option value="theme-gazprom-classic">Классический синий</option>
                    <option value="theme-gazprom-dark">Глубокий космос</option>
                    <option value="theme-gazprom-light">Полярный день</option>
                </select>
            </div>
            <div class="dev-group">
                <label>Звуки (Органичные)<input type="checkbox" id="sound-effects-toggle"></label>
            </div>
            <div class="dev-group">
                <label>Дышащие карты (свечение)<input type="checkbox" id="breathing-cards-toggle"></label>
            </div>
            <div class="dev-group">
                <label>Ripple эффект (заливка)<input type="checkbox" id="ripple-effects-toggle"></label>
            </div>
            <div class="dev-group">
                <label>Магнитное притяжение<input type="checkbox" id="magnetic-snap-toggle"></label>
            </div>
            <div class="dev-group">
                <label>Confetti анимация<input type="checkbox" id="confetti-toggle"></label>
            </div>
            <div class="dev-group">
                <label>Вибрация телефона<input type="checkbox" id="vibration-toggle"></label>
            </div>
            <div class="dev-group">
                <label>Дыхание колоды<input type="checkbox" id="deck-breathing-toggle"></label>
            </div>
            <button id="restart-app-btn">Перезапустить</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script src="data.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const screens = { start: document.getElementById('start-screen'), focus: document.getElementById('focus-screen'), choice: document.getElementById('choice-screen') };
            const buttons = { start: document.getElementById('start-btn'), closeModal: document.getElementById('close-modal-btn'), geminiSubmit: document.getElementById('gemini-submit') };
            const containers = { cardSlots: document.querySelectorAll('.card-slot'), cardArea: document.getElementById('card-selection-area'), modalSpread: document.querySelector('.modal-spread-container'), app: document.querySelector('.app-container') };
            const modal = { overlay: document.getElementById('result-modal') };
            const devPanel = {
                toggle: document.getElementById('dev-panel-toggle'), content: document.getElementById('dev-panel-content'),
                themeSelect: document.getElementById('theme-select'), soundToggle: document.getElementById('sound-effects-toggle'),
                breathingToggle: document.getElementById('breathing-cards-toggle'), rippleToggle: document.getElementById('ripple-effects-toggle'),
                magneticToggle: document.getElementById('magnetic-snap-toggle'), confettiToggle: document.getElementById('confetti-toggle'),
                vibrationToggle: document.getElementById('vibration-toggle'), deckBreathingToggle: document.getElementById('deck-breathing-toggle'),
                restartBtn: document.getElementById('restart-app-btn')
            };

            let chosenCards = new Array(3).fill(null);
            let draggedCard = null, dragOffset = { x: 0, y: 0 };
            let confettiCanvas, confettiContext, confettiParticles = [];
            let audioContext, sounds = {};

            let effects = {
                sounds: { enabled: true }, breathing: { enabled: true }, ripple: { enabled: true },
                magnetic: { enabled: true }, confetti: { enabled: true }, vibration: { enabled: false },
                deckBreathing: { enabled: false }
            };

            function loadEffectsFromStorage() {
                const saved = localStorage.getItem('tarot-effects');
                if (saved) { try { effects = { ...effects, ...JSON.parse(saved) }; } catch (e) { console.error(e); } }
            }
            function saveEffectsToStorage() { localStorage.setItem('tarot-effects', JSON.stringify(effects)); }

            function applyEffectsToUI() {
                devPanel.soundToggle.checked = effects.sounds.enabled;
                devPanel.breathingToggle.checked = effects.breathing.enabled;
                devPanel.rippleToggle.checked = effects.ripple.enabled;
                devPanel.magneticToggle.checked = effects.magnetic.enabled;
                devPanel.confettiToggle.checked = effects.confetti.enabled;
                devPanel.vibrationToggle.checked = effects.vibration.enabled;
                devPanel.deckBreathingToggle.checked = effects.deckBreathing.enabled;
            }

            function initAudio() {
                if (!audioContext && effects.sounds.enabled) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const sine = (freq, vol, dur) => createTone(freq, dur, vol);
                        sounds = {
                            cardClick: () => sine(659, 0.15, 0.5), cardDrop: () => sine(523, 0.2, 0.8), cardFlip: () => sine(784, 0.12, 0.6),
                            complete: () => { sine(523, 0.1, 0.5)(); setTimeout(() => sine(659, 0.1, 0.5)(), 100); setTimeout(() => sine(784, 0.1, 0.5)(), 200); }
                        };
                    } catch (e) { console.warn('Audio not supported'); effects.sounds.enabled = false; }
                }
            }

            function createTone(frequency, duration, volume, type = 'sine') {
                return () => {
                    if (!audioContext || !effects.sounds.enabled) return;
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
                    oscillator.type = type;
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                };
            }
            function playSound(soundName) { if (sounds[soundName]) sounds[soundName](); }
            function vibrate(pattern) { if (effects.vibration.enabled && 'vibrate' in navigator) navigator.vibrate(pattern); }

            function createRipple(x, y, element) {
                if (!effects.ripple.enabled) return;
                const ripple = document.createElement('div');
                ripple.className = 'ripple-v1';
                const size = 100;
                ripple.style.width = `${size}px`;
                ripple.style.height = `${size}px`;
                ripple.style.left = `${x - size / 2}px`;
                ripple.style.top = `${y - size / 2}px`;
                element.appendChild(ripple);
                setTimeout(() => ripple.remove(), 600);
            }

            function updateBreathingCards() {
                document.querySelectorAll('.tarot-card:not(.is-dropped)').forEach(c => c.classList.toggle('breathing-glow', effects.breathing.enabled));
            }
            function updateMagneticSlots() {
                containers.cardSlots.forEach(s => s.classList.toggle('magnetic-pulse', effects.magnetic.enabled));
            }
            function updateDeckBreathing() {
                const deck = document.getElementById('initial-deck');
                if (deck) deck.classList.toggle('deck-breathing-mystic', effects.deckBreathing.enabled);
            }

            function switchScreen(screenName) {
                Object.values(screens).forEach(s => s.classList.remove('active'));
                screens[screenName].classList.add('active');
            }

            function initParticles() {
                const theme = document.body.className || 'theme-gazprom-classic';
                const colors = { 'theme-gazprom-classic': { p: "#00aaff", l: "#0078d7" }, 'theme-gazprom-dark': { p: "#3399ff", l: "#005f9e" }, 'theme-gazprom-light': { p: "#0078d7", l: "#005a9e" } };
                const color = colors[theme] || colors['theme-gazprom-classic'];
                if (window.particlesJS) particlesJS('particles-js', { particles: { number: { value: 60 }, color: { value: color.p }, size: { value: 3, random: true }, move: { enable: true, speed: 2 }, line_linked: { color: color.l, distance: 150 } }, interactivity: { events: { onhover: { enable: true, mode: "repulse" } } } });
            }

            function setupChoiceScreen() {
                switchScreen('choice');
                const explanation = document.getElementById('slot-explanation');
                if(explanation) explanation.style.opacity = 1;

                chosenCards.fill(null);
                containers.cardSlots.forEach((slot, index) => {
                    slot.innerHTML = `<span class="slot-label">${["Вызов", "Путь", "Исход"][index]}</span>`;
                    slot.classList.remove('filled');
                });
                containers.cardArea.innerHTML = '';
                const initialDeck = document.createElement('div');
                initialDeck.id = 'initial-deck';
                for (let i = 0; i < 5; i++) {
                    const card = document.createElement('div');
                    card.className = 'shuffle-card';
                    card.style.transform = `translateZ(${i * -2}px)`;
                    initialDeck.appendChild(card);
                }
                containers.cardArea.appendChild(initialDeck);
                updateDeckBreathing();
                initialDeck.addEventListener('click', dealCardsFromDeck, { once: true });
            }

            function dealCardsFromDeck() {
                const deck = document.getElementById('initial-deck');
                if (!deck) return;

                gsap.to('#slot-explanation', { opacity: 0, duration: 0.3, pointerEvents: 'none' });

                const shuffledCards = [...tarotCardsData].sort(() => 0.5 - Math.random());
                const deckRect = deck.getBoundingClientRect();
                const areaRect = containers.cardArea.getBoundingClientRect();

                shuffledCards.forEach((cardData, index) => {
                    const cardElement = document.createElement('div');
                    cardElement.className = 'tarot-card';
                    cardElement.dataset.id = cardData.id;
                    cardElement.innerHTML = `<div class="card-face card-back"></div>`;
                    
                    cardElement.style.left = `${deckRect.left - areaRect.left}px`;
                    cardElement.style.top = `${deckRect.top - areaRect.top}px`;
                    containers.cardArea.appendChild(cardElement);

                    const slotRect = containers.cardSlots[0].getBoundingClientRect();
                    const availableWidth = slotRect.left - areaRect.left - cardElement.clientWidth - 20;
                    
                    const finalX = Math.random() * availableWidth + 10;
                    const finalY = Math.random() * (areaRect.height - cardElement.clientHeight - 20) + 10;
                    const finalRotation = Math.random() * 40 - 20;

                    gsap.to(cardElement, { 
                        left: finalX, top: finalY, rotation: finalRotation,
                        duration: 0.7, delay: index * 0.02, ease: 'power2.out' 
                    });
                });
                
                gsap.to(deck, { opacity: 0, duration: 0.5, onComplete: () => deck.remove() });

                setTimeout(() => {
                    document.querySelectorAll('.tarot-card').forEach(card => {
                        card.addEventListener('mousedown', startDrag);
                        card.addEventListener('touchstart', startDrag, { passive: false });
                    });
                    updateBreathingCards();
                    updateMagneticSlots();
                }, shuffledCards.length * 20 + 700);
            }

            function startDrag(e) {
                e.preventDefault();
                draggedCard = e.target.closest('.tarot-card');
                if (draggedCard.classList.contains('is-dropped')) return;

                initAudio(); playSound('cardClick'); vibrate(50);
                
                const rect = draggedCard.getBoundingClientRect();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                dragOffset = { x: clientX - rect.left, y: clientY - rect.top };
                
                draggedCard.classList.add('is-dragging');
                gsap.to(draggedCard, { scale: 1.1, duration: 0.2 });
                createRipple(clientX - rect.left, clientY - rect.top, draggedCard);

                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', endDrag);
                document.addEventListener('touchmove', handleDrag, { passive: false });
                document.addEventListener('touchend', endDrag);
            }
            
            function handleDrag(e) {
                if (!draggedCard) return;
                e.preventDefault();
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const parentRect = containers.cardArea.getBoundingClientRect();
                
                const newX = clientX - parentRect.left - dragOffset.x;
                const newY = clientY - parentRect.top - dragOffset.y;
                draggedCard.style.left = `${newX}px`;
                draggedCard.style.top = `${newY}px`;

                let closestSlot = null;
                let minDistance = Infinity;
                const cardRect = draggedCard.getBoundingClientRect();
                const cardCenterX = cardRect.left + cardRect.width / 2;
                const cardCenterY = cardRect.top + cardRect.height / 2;

                containers.cardSlots.forEach(slot => {
                    if (slot.classList.contains('filled')) return;
                    const slotRect = slot.getBoundingClientRect();
                    const slotCenterX = slotRect.left + slotRect.width / 2;
                    const slotCenterY = slotRect.top + slotRect.height / 2;
                    const distance = Math.hypot(cardCenterX - slotCenterX, cardCenterY - slotCenterY);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestSlot = slot;
                    }
                });

                containers.cardSlots.forEach(slot => {
                    const shouldActivate = (slot === closestSlot && minDistance < slot.clientWidth);
                    slot.classList.toggle('drag-over', shouldActivate);
                    slot.classList.toggle('attracting', shouldActivate && effects.magnetic);
                });
            }

            function endDrag() {
                if (!draggedCard) return;
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', endDrag);
                document.removeEventListener('touchmove', handleDrag);
                document.removeEventListener('touchend', endDrag);
                draggedCard.classList.remove('is-dragging');

                let droppedSlot = document.querySelector('.card-slot.drag-over');
                if (droppedSlot) {
                    handleDrop(draggedCard, droppedSlot);
                } else {
                    gsap.to(draggedCard, { scale: 1, duration: 0.3, ease: 'back.out' });
                }
                
                containers.cardSlots.forEach(slot => slot.classList.remove('drag-over', 'attracting'));
                draggedCard = null;
            }

            function handleDrop(cardElement, slot) {
                const cardData = tarotCardsData.find(c => c.id == cardElement.dataset.id);
                const slotId = parseInt(slot.dataset.slotId);
                const labels = ["Ваш Вызов", "Ваш Путь", "Ваш Исход"];
                chosenCards[slotId] = cardData;

                playSound('cardDrop'); vibrate(100);
                cardElement.style.pointerEvents = 'none';
                slot.classList.add('filled');
                
                const slotRect = slot.getBoundingClientRect();
                const areaRect = containers.cardArea.getBoundingClientRect();
                
                gsap.to(cardElement, {
                    left: slotRect.left - areaRect.left, 
                    top: slotRect.top - areaRect.top,
                    scale: 1, 
                    rotation: 0, 
                    duration: 0.4, 
                    ease: 'power2.inOut',
                    onComplete: () => {
                        cardElement.removeAttribute('style');
                        
                        slot.appendChild(cardElement);
                        cardElement.innerHTML = `<div class="card-face card-back"></div><div class="card-face card-front" style="background-image: url('${cardData.image}')"></div>`;
                        
                        gsap.to(cardElement, { 
                            rotationY: 180,
                            duration: 0.7,
                            ease: 'power2.inOut'
                        });

                        showPlacementToast(labels[slotId], cardData.name);
                        playSound('cardFlip');

                        if (chosenCards.filter(c => c).length === 3) {
                            playSound('complete'); vibrate([100, 50, 100]);
                            if(effects.confetti) createConfettiParticles();
                            setTimeout(showResult, 2500);
                        }
                    }
                });
            }
            
            function showPlacementToast(slotName, cardName) {
                const toast = document.createElement('div');
                toast.className = 'placement-toast';
                toast.innerHTML = `<h4>${slotName}</h4><p>${cardName}</p>`;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 2500);
            }

            function showResult() {
                const labels = ["Вызов", "Путь", "Исход"];
                containers.modalSpread.innerHTML = chosenCards.map((cardData, i) => {
                    if (!cardData) return '';
                    const keywordsHTML = cardData.keywords.split(',').map(k => `<span class="keyword">${k.trim()}</span>`).join('');
                    return `
                        <div class="modal-card-display">
                            <img src="${cardData.image}" alt="${cardData.name}">
                            <div class="card-details">
                                <h4>${labels[i]}: ${cardData.name}</h4>
                                <p><em>${cardData.general}</em></p>
                                <h5>Для проекта:</h5> <p>${cardData.project}</p>
                                <h5>Для карьеры:</h5> <p>${cardData.career}</p>
                                <div class="keywords-container">${keywordsHTML}</div>
                            </div>
                        </div>`;
                }).join('');
                modal.overlay.classList.add('active');
            }

            function initConfetti() {
                confettiCanvas = document.getElementById('confetti-canvas');
                confettiContext = confettiCanvas.getContext('2d');
                const resize = () => { confettiCanvas.width = window.innerWidth; confettiCanvas.height = window.innerHeight; };
                window.addEventListener('resize', resize); resize();
            }
            function createConfettiParticles() {
                if (!effects.confetti) return;
                for (let i = 0; i < 50; i++) confettiParticles.push({ x: Math.random() * confettiCanvas.width, y: -20, vx: Math.random() * 10 - 5, vy: Math.random() * 5 + 5, color: ['#00aaff', '#0078d7', '#ffffff'][Math.floor(Math.random() * 3)], size: Math.random() * 8 + 4 });
                if (confettiParticles.length > 0) animateConfetti();
            }
            function animateConfetti() {
                confettiContext.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                for (let i = confettiParticles.length - 1; i >= 0; i--) {
                    const p = confettiParticles[i]; p.x += p.vx; p.y += p.vy; p.vy += 0.2;
                    confettiContext.fillStyle = p.color; confettiContext.fillRect(p.x, p.y, p.size, p.size);
                    if (p.y > confettiCanvas.height + 20) confettiParticles.splice(i, 1);
                }
                if (confettiParticles.length > 0) requestAnimationFrame(animateConfetti);
            }
            
            function setupDevPanel() {
                devPanel.toggle.addEventListener('click', () => devPanel.content.classList.toggle('active'));
                devPanel.themeSelect.addEventListener('change', (e) => { document.body.className = e.target.value; initParticles(); });
                devPanel.soundToggle.addEventListener('change', (e) => { effects.sounds.enabled = e.target.checked; saveEffectsToStorage(); });
                devPanel.breathingToggle.addEventListener('change', (e) => { effects.breathing.enabled = e.target.checked; updateBreathingCards(); saveEffectsToStorage(); });
                devPanel.rippleToggle.addEventListener('change', (e) => { effects.ripple.enabled = e.target.checked; saveEffectsToStorage(); });
                devPanel.magneticToggle.addEventListener('change', (e) => { effects.magnetic.enabled = e.target.checked; updateMagneticSlots(); saveEffectsToStorage(); });
                devPanel.confettiToggle.addEventListener('change', (e) => { effects.confetti.enabled = e.target.checked; saveEffectsToStorage(); });
                devPanel.vibrationToggle.addEventListener('change', (e) => { effects.vibration.enabled = e.target.checked; saveEffectsToStorage(); });
                devPanel.deckBreathingToggle.addEventListener('change', (e) => { effects.deckBreathing.enabled = e.target.checked; updateDeckBreathing(); saveEffectsToStorage(); });
                devPanel.restartBtn.addEventListener('click', () => { saveEffectsToStorage(); location.reload(); });
            }

            function init() {
                loadEffectsFromStorage(); applyEffectsToUI(); initParticles(); initConfetti(); setupDevPanel();
                buttons.start.addEventListener('click', () => {
                    switchScreen('focus'); containers.app.classList.add('focus-active');
                });
                screens.focus.addEventListener('click', () => {
                    containers.app.classList.remove('focus-active');
                    setupChoiceScreen();
                });
                buttons.closeModal.addEventListener('click', () => {
                    modal.overlay.classList.remove('active');
                    setTimeout(setupChoiceScreen, 500);
                });
                switchScreen('start');
            }

            init();
        });
    </script>
</body>
</html>